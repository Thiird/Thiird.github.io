{
    "cpu_types": {
        "text": "<strong>CPU (Central Processing Unit)</strong>: The general term for a general-purpose computer IC. Typically run at high clock speeds (GHz range). Used for complex devices devices like TVs.<br>For example, the ARM Cortex-A53 .<br><br><strong>MCU (Microcontroller Unit)</strong>: The same base architecture as a CPU, but with integrated RAM, EEPROM and run at lower clock speeds (MHz range). Used for simple devices like a mouse and keyboard.<br>For example, the STM32F4.<br><br><strong>DSP (Digital Signal Processor)</strong>: A CPU designed with special instructions for mathematical operations. These chips excel at repetitive math-intensive tasks required in signal processing applications.<br>For example, the Texas Instruments TMS320C6000.",
        "media": "",
        "alt": ""
    },
    "awareness_keyboard": {
        "text": "",
        "media": "awareness_keyboard.gif",
        "alt": ""
    },
    "casio_watch": {
        "text": "",
        "media": "casio_watch.png",
        "alt": ""
    },
    "ecu": {
        "text": "",
        "media": "ecu.jpg",
        "alt": ""
    },
    "soviet_seeker": {
        "text": "",
        "media": "soviet_seeker.gif",
        "alt": ""
    },
    "paw3395": {
        "text": "High-performance gaming optical sensor with 30,000 DPI capability",
        "media": "tooltip.gif"
    },
    "isa": {
        "text": "The ISA defines, along <em>many</em> other things, both the text and the binary representation of the machine instructions.<br><br>The text-form is used to write programs directly in machine language, which takes the name of <strong>assembly language</strong>. To execute it on the CPU, it then needs to be translated via an <em>assembler</em>, to the binary representation.<br><br>Some of the most common CPU instructions are:<br><em>(R = CPU register)</em><br>- <strong>ADD R1, R2, R3</strong>: (R1 = R2 + R3)<br>- <strong>MUL R1, R2, R3</strong>: (R1 = R2 × R3)<br>- <strong>CMP R1, R2</strong>: Compare two values<br>- <strong>JMP 0x1000</strong>: Jump to the given memory address",
        "media": ""
    },
    "ES": {
        "text": "Embedded System",
        "media": ""
    },
    "CU": {
        "text": "Computational Unit",
        "media": ""
    },
    "CPU": {
        "text": "Central Processing Unit",
        "media": ""
    },
    "ASIC": {
        "text": "Application Specific Integrated Circuit",
        "media": ""
    },
    "FPGA": {
        "text": "Field-Programmable Gate Array",
        "media": ""
    },
    "dmm": {
        "text": "Digital Multimeter",
        "media": "dmm.jpg"
    },
    "oscilloscope": {
        "text": "Two channel oscilloscope measuring the output of a circuit.",
        "media": "oscilloscope.jpg",
        "alt": "https://learn.sparkfun.com/"
    },
    "oscilloscope_data_rate": {
        "text": "<strong>Example:<br></strong> To correctly sample a <strong>1 MHz signal</strong>, a minimum of <strong>2 million samples per second</strong> are required (Nyquist theorem). To display all of this data, a digit screen would need to update every <strong>0.5 microseconds</strong>, far beyond what a simple digit display can handle, let alone a human reading it.",
        "media": ""
    },
    "digit_screen": {
        "text": "",
        "media": ""
    },
    "oscilloscope_channels": {
        "text": "<strong>Input Channels</strong><br><br>The maximum number of signals an oscilloscope can measure and display simultaneously. Entry-level oscilloscopes typically have 2 to 4 channels, while professional models have more. Multiple channels let you compare signals side-by-side, essential for debugging communication protocols.",
        "media": ""
    },
    "signal_analysis_capabilities": {
        "text": "<strong>Advanced Signal Analysis</strong><br><br>Higher-end oscilloscopes include built-in analysis functions beyond basic waveform display:<br><br>- <strong>FFT (Fast Fourier Transform)</strong>: Converts time-domain signals to frequency domain, revealing harmonic content and noise characteristics<br>- <strong>Protocol Decoding</strong>: Automatically decodes digital protocols like I2C, SPI, UART, CAN<br>- <strong>Math Functions</strong>: Perform operations like addition, subtraction, integration, differentiation on signals<br>- <strong>Automated Measurements</strong>: Calculate rise time, fall time, jitter, phase differences automatically",
        "media": ""
    },
    "oscilloscope_signal_visualization": {
        "text": "The graphical representation makes it easy to understand signal behavior at a glance. While signals can also be analyzed by computers using math, the oscilloscope is designed to be an hands-on debugging.",
        "media": ""
    },
    "amm": {
        "text": "Analog Multimeter",
        "media": ""
    },
    "waves": {
        "text": "From top to bottom, a sine wave, a square wave, and a triangular wave.<br>Note how, if the period of the multimeter sampling would correspond with the middle point of the on part of the square wave, the multimeter would always read the maximum voltage, completely hiding the switching behavior of all three signals",
        "media": "waves.jpg"
    },
    "es_nuances": {
        "text": "This is true for both the software and the hardware side.",
        "media": ""
    },    "signal_integrity_issues": {
        "text": "<strong>Noise</strong>: Unwanted electrical interference that appears on top of the signal.<br><br><strong>Ringing</strong>: Oscillations that occur when a signal changes value fast.",
        "media": ""
    },
    "signal_characteristics": {
        "text": "<strong>Frequency</strong>: How many times per second the signal repeats (measured in Hz).<br><br><strong>Rise/Fall Time</strong>: How quickly a signal transitions between low and high states, important for high-speed digital circuits.<br><br><strong>Timing Relationships</strong>: Phase differences and synchronization between multiple signals.",
        "media": ""
    },
    "flash_program": {
        "text": "Writing the program binary file on the MCU EEPROM",
        "media": ""
    },
    "jtag_advanced_functionalities": {
        "text": "<strong>Boundary Scan</strong>: Test connections between chips on a PCB without physical probes<br> <strong>Chain Debugging</strong>: Debug multiple devices connected in a daisy-chain topology",
        "media": ""
    },
    "heat_seeking_missile": {
        "text": "",
        "media": "",
        "alt": ""
    },
    "PCB_image": {
        "text": "",
        "media": "awareness_macropad_pcb.jpg",
        "alt": ""
    },
    "PCB": {
        "text": "Printed Circuit Board",
        "media": "",
        "alt": ""
    },
    "embedded": {
        "text": "",
        "media": "embedded.gif",
        "alt": ""
    },
    "IC": {
        "text": "<strong>Integrated Circuit</strong><br><br>A set of transistors, resistors, and capacitors implemented on a semiconductor material, working together to perform complex functions. Modern integrated circuits contain billions of transistors.<br><br><em>Shown below, a die shot of the <a href=\"https://en.wikipedia.org/wiki/Electronics_industry_in_the_Socialist_Republic_of_Romania#History\" target=\"_blank\">CII 72</a>, which comprises two voltage comparators with separate differential inputs.<br>For more, google 'IC die shot'.</em>",
        "media": "CII_72_silicon_die.jpg"
    },
    "electronic": {
        "text": "It's important to define the distinction between <em>electrical</em> and <em>electronic</em>.<br><br>- <strong>Electrical</strong>: means \"current flowing through wires\", for example motors, simple wirings and lighting.<br>- <strong>Electronic</strong>: means \"current flowing through active components that perform computation\", like diodes, transistor and ultimately computers.",
        "media": ""
    },
    "cpu_non_triviality": {
        "text": "CPUs allow everyone to have a computer for their own needs at low cost: just make as many CPUs as needed and program them differently. It's hard to overstate how much this changed the world.",
        "media": ""
    },
    "softcore": {
        "text": "<italics>This assumes the FPGA has sufficient resources (logic blocks, RAM, etc.).</italics><br><br>For example, you can configure an FPGA to be a CPU, which takes the name of <a href=\"https://en.wikipedia.org/wiki/Field-programmable_gate_array#Soft_core\" target=\"_blank\"><strong>softcore</strong></a>. A softcore is a CPU implemented using the programmable logic of an FPGA, rather than as a fixed silicon design.",
        "media": ""
    },
    "logic_block_details": {
        "text": "Logic blocks can implement <a href=\"https://en.wikipedia.org/wiki/Combinational_logic\" target=\"_blank\">combinational logic</a> (via lookup tables) and typically include flip-flops for <a href=\"https://en.wikipedia.org/wiki/Sequential_logic\" target=\"_blank\">sequential logic</a> and state storage.",
        "media": ""
    },
    "target_fpga_model": {
        "text": "Different FPGAs have different architectures and resources available (number of CLBs, RAM blocks, etc.), so they need different configurations to yield the same result.",
        "media": ""
    },
    "synthesis_toolchain": {
        "text": "This is akin to how different CPU compilers generate different assembly for the same input code.",
        "media": ""
    },
    "vias": {
        "text": "<strong><a href=\"https://en.wikipedia.org/wiki/Via_(electronics)\" target=\"_blank\">Vias</a></strong><br><br>Small plated holes that connect copper traces on different layers of a PCB, allowing electrical signals to pass between layers.",
        "media": "vias.png",
        "alt": "Taken from https://www.vse.com/blog/how-are-pcb-vias-plated/"
    },
    "chip": {
        "text": "Chips are integrated circuits embedded in a package that provides physical protection and electrical connections.<br><br>Shown below, is the commonly used Quad Flat No-lead (QFN) package.",
        "media": "qfn_hand_shot.jpg",
        "alt": "https://www.top-electronics.com/"
    },
    "resistors": {
        "text": "<strong>Resistors</strong><br><br>Electrical components that resist the flow of electrical current, used to control voltage and current levels in a circuit.",
        "media": "resistors.jpg",
        "alt": "https://icdigest.com/"
    },
    "capacitors": {
        "text": "<strong>Capacitors</strong><br><br>Electrical components that store electrical energy in an electric field, used for filtering, timing, and energy storage applications.",
        "media": "capacitors.jpg",
        "alt": "https://icdigest.com/"
    },
    "inductors": {
        "text": "<strong>Inductors</strong><br><br>Electrical components that store energy in a magnetic field when electrical current flows through them, used for filtering and energy storage.",
        "media": "inductors.jpg",
        "alt": "https://icdigest.com/"
    },
    "connectors": {
        "text": "<strong>Connectors</strong><br><br>Physical interfaces that allow electrical connections to be made and broken between different parts of a system, such as USB ports, pin headers, and terminal blocks.",
        "media": "connectors.gif"
    },
    "soldering_iron": {
        "text": "",
        "media": "soldering_iron.jpg",
        "alt": "https://www.aixuntech.com/"
    },
    "bench_power_supply": {
        "text": "High-end bench power supply with three channels.",
        "media": "bench_power_supply.png",
        "alt": "https://www.keysight.com/"
    },
    "soldering_robot": {
        "text": "",
        "media": "soldering_robot.gif",
        "alt": "Weller youtube channel"
    },
    "reflow_oven": {
        "text": "<strong>Reflow Oven</strong><br><br>Industrial ovens that heat PCBs with pre-applied solder paste to precisely controlled temperatures, melting the solder and creating permanent connections between components and the board. Commonly used in mass production of electronics.",
        "media": "reflow_oven.jpg",
        "alt": "https://en.wikipedia.org/wiki/Reflow_oven"
    },
    "perfboard": {
        "text": "<strong>Perfboard</strong><br><br>A prototyping board with pre-drilled holes arranged in a grid pattern. Components are inserted from one side and soldered on the other, with connections made by soldering component leads together or using wire jumpers.",
        "media": "perfboard.gif",
        "alt": "https://www.bestpcbs.com/, https://electronics.stackexchange.com/"
    },
    "intermediate_circuitry_input": {
        "text": "<strong>Intermediate Circuitry for Inputs</strong><br><br>Sometimes sensors can't connect directly to the computational unit and need interface circuitry in between.<br><br>For example, to measure a 12V battery voltage with a microcontroller that only tolerates 3.3V on its pins, you'd use a <em>voltage divider</em> - two resistors in series that scale down the voltage to a safe range (e.g., 12V → 3V) before connecting to the MCU's analog input pin.",
        "media": ""
    },
    "intermediate_circuitry_output": {
        "text": "<strong>Intermediate Circuitry for Outputs</strong><br><br>Sometimes output devices can't be driven directly by the computational unit and need interface circuitry in between.<br><br>For example, high-power LEDs require much more current than a microcontroller pin can provide (typically 20-40mA max). An <em>LED driver</em> circuit takes the low-power control signal from the MCU and uses it to switch higher currents (hundreds of mA or more) through the LED safely.",
        "media": ""
    },
    "dsp_example": {
        "text": "Think of the electronics that controls a RADAR, for example.",
        "media": ""
    },
    "firmware_unchanged": {
        "text": "This is because:<br>- Firmware directly controls the hardware, and the hardware doesn't change: once it's done it's done<br>- Specialized tools are needed to program embedded devices, end users don't have them",
        "media": ""
    },
    "bare_metal_example": {
        "text": "A single line of code can change the voltage level of a single pin of a microcontroller, allowing it, for example, to toggle an LED.",
        "media": ""
    },
    "hardware_capabilities": {
        "text": "Think of systems with many cores, many peripherals.",
        "media": ""
    },
    "system_logic": {
        "text": "Think of a system that is handling multiple input/output data streams over many different communication protocols.",
        "media": ""
    },
    "bench_power_supply_example": {
        "text": "An example is a modern bench power supply: the firmware controls the voltage and current settings based on the front panel buttons and dials, while the software exposes a web interface for remote control and configuration. You might update the software to add new features, but the firmware remains stable (unless a bug is found) as the front panel is always the same.",
        "media": ""
    },
    "ESD_protection": {
        "text": "<strong>ESD Protection</strong><br><br>Electrostatic Discharge protection circuits prevent damage from static electricity. Clamping voltage spikes to safe levels, protects sensitive electronics from the thousands of volts that can build up from simple actions like touching a doorknob.",
        "media": ""
    },
    "reverse_polarity_protection": {
        "text": "<strong>Reverse Polarity Protection</strong><br><br>Prevents damage when power is connected backwards. Reversing power can instantly destroy components.",
        "media": ""
    },
    "overcurrent_protection": {
        "text": "<strong>Overcurrent Protection</strong><br><br>Limits or cuts off current flow when it exceeds safe levels, preventing component damage and fire hazards.",
        "media": ""
    },
    "debugger": {
        "text": "A JLink debugger.<br>On the top side, the debugger is connected via USB to the PC, on the bottom side instead, it's connected to a PCB for programming and debugging.<br> The PC side is always either USB or Ethernet, the device side is device dependant, both in the protocol used and the cable/connectors required.",
        "media": "debugger.jpg"
    },
    "PCB_manufacturing": {
        "text": "etched/milled",
        "media": ""
    },
    "full_os_requirements": {
        "text": "Not all embedded systems can run full-fledged OSes like Linux or Android. These OSes require a <strong>Memory Management Unit (MMU)</strong>, a hardware component that translates virtual addresses to physical addresses.<br><br>The MMU enables each process to have its own isolated address space, which is fundamental to how Linux and Android manage multiple applications. Most microcontrollers lack an MMU, which is why they run bare-metal code or lightweight RTOSes instead.",
        "media": ""
    },
    "pcb_pads": {
        "text": "<strong>PCB Pads</strong><br><br>Exposed metal areas on a PCB where components are soldered. Pads provide both mechanical support and electrical connection between components and the PCB traces.",
        "media": "pcb_pads.jpg",
        "alt": ""
    },
    "solder_paste": {
        "text": "<strong>Solder Paste</strong><br><br>A sticky mixture of tiny solder balls suspended in flux. Applied to PCB pads before component placement, it melts during the reflow process to create permanent electrical connections.",
        "media": "solder_paste.jpg",
        "alt": ""
    },
    "mesmerizing_reflow": {
        "text": "Watching solder paste melt and components seemingly snap into perfect alignment as surface tension pulls them into place is genuinely fascinating.",
        "media": "reflow_mesmerizing.gif",
        "alt": ""
    }
}